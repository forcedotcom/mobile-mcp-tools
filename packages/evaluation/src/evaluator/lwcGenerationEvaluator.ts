/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import { fileURLToPath } from 'url';
import path, { dirname, join } from 'path';
import { LwcEvaluatorAgent, Score } from '../agent/lwcEvaluatorAgent.js';
import LwcComponentAgent from '../agent/lwcComponentAgent.js';
import { EvaluationUnit } from '../utils/lwcUtils.js';
import { LlmClient } from '../llmclient/llmClient.js';
import { spawn, ChildProcess } from 'child_process';
import { BaseEvaluator } from './baseEvaluator.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
export const EVAL_DATA_FOLDER = join(__dirname, '../../dataset');

/**
 * This class calls the judge model to evaluate the quality of
 * the LWC component generated by the modelToEval against
 * the reference LWC in the training data
 */
import { MobileWebMcpClient } from '../mcpclient/mobileWebMcpClient.js';

export class LwcGenerationEvaluator extends BaseEvaluator {
  private readonly evaluatorAgent: LwcEvaluatorAgent;
  private readonly componentAgent: LwcComponentAgent;
  private serverProcess: ChildProcess;
  private mobileWebMcpClient: MobileWebMcpClient;

  constructor(evaluatorLlmClient: LlmClient, componentLlmClient: LlmClient) {
    super();
    this.evaluatorAgent = new LwcEvaluatorAgent(evaluatorLlmClient);
    this.componentAgent = new LwcComponentAgent(componentLlmClient);
  }

  static async create(
    evaluatorLlmClient: LlmClient,
    componentLlmClient: LlmClient
  ): Promise<LwcGenerationEvaluator> {
    const evaluator = new LwcGenerationEvaluator(evaluatorLlmClient, componentLlmClient);
    await evaluator.initializeMobileWebMcpClient();
    return evaluator;
  }

  async destroy(): Promise<void> {
    await super.destroy();
    console.log('ðŸ”„ Starting evaluator cleanup...');

    if (this.mobileWebMcpClient) {
      console.log('ðŸ”„ Disconnecting MCP client...');
      await this.mobileWebMcpClient.disconnect();
      console.log('âœ… MCP client disconnected');
    }

    if (this.serverProcess) {
      console.log('ðŸ”„ Terminating server process...');
      this.serverProcess.kill('SIGTERM');
      // Give the process a moment to terminate gracefully
      await new Promise(resolve => setTimeout(resolve, 1000));
      // Force kill if still running
      if (!this.serverProcess.killed) {
        console.log('ðŸ”„ Force killing server process...');
        this.serverProcess.kill('SIGKILL');
      }
      console.log('âœ… Server process terminated');
    }

    console.log('âœ… Evaluator cleanup completed');
  }

  /**
   * Evaluate the quality of the LWC component generated by the modelToEval against the reference LWC implementation
   * @param input - The component name to evaluate
   * @returns The score of the component
   */
  async evaluate(evaluationUnit: EvaluationUnit): Promise<Score> {
    const mcpGroundings = await this.getMcpGroundings(evaluationUnit);

    const resultLwc = await this.componentAgent.generateLwcComponent(
      evaluationUnit.query,
      mcpGroundings
    );
    return await this.evaluatorAgent.evaluate(evaluationUnit.component, resultLwc);
  }

  private async getMcpGroundings(evaluationUnit: EvaluationUnit): Promise<string | undefined> {
    const groundings = [];
    if (evaluationUnit.config.mcpTools) {
      for (const tool of evaluationUnit.config.mcpTools) {
        const result = await this.mobileWebMcpClient.callTool(tool.toolId, tool.params);
        const groundingContext = result.content?.[0]?.text;
        if (groundingContext) {
          groundings.push(groundingContext);
        }
      }
    }
    return groundings.join('\n');
  }

  private async initializeMobileWebMcpClient(): Promise<void> {
    console.log('ðŸ”„ Starting MCP server...');
    this.serverProcess = spawn('npm', ['run', 'mobile-web:server:start'], {
      cwd: path.resolve(__dirname, '../../../..'),
      stdio: ['pipe', 'pipe', 'pipe'],
      shell: true,
    });

    // Add process event handlers for debugging
    this.serverProcess.on('error', error => {
      console.error('âŒ Server process error:', error);
    });

    this.serverProcess.on('exit', (code, signal) => {
      console.log(`ðŸ”„ Server process exited with code: ${code}, signal: ${signal}`);
    });

    this.mobileWebMcpClient = new MobileWebMcpClient();
    await this.connectToMcpServer();
  }

  /**
   * Connect to the MCP server and wait for it to be ready
   * @param maxRetries - The maximum number of retries
   * @param retryIntervalMs - The interval between retries
   */
  private async connectToMcpServer(
    maxRetries: number = 30,
    retryIntervalMs: number = 1000
  ): Promise<void> {
    let retries = 0;

    while (retries < maxRetries) {
      try {
        // Try to create and connect a test client

        await this.mobileWebMcpClient.connect();
        // If we can list tools, server is ready
        await this.mobileWebMcpClient.listTools();
        console.log('MCP server is ready');
        return;
      } catch (error) {
        retries++;
        console.log(`Waiting for MCP server to be ready... (attempt ${retries}/${maxRetries})`);

        if (retries >= maxRetries) {
          throw new Error(
            `MCP server failed to start after ${maxRetries} attempts. Last error: ${error}`
          );
        }

        await new Promise(resolve => setTimeout(resolve, retryIntervalMs));
      }
    }
  }
}
