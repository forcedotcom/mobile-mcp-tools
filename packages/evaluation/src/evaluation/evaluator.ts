import { fileURLToPath } from 'url';
import path, { dirname, join } from 'path';
import { LwcEvaluatorAgent, Score } from './lwcEvaluatorAgent.js';
import LwcComponentAgent from './lwcComponentAgent.js';
import { loadEvaluationUnit, EvaluationUnit } from '../utils/lwcUtils.js';
import { LlmClient } from '../llmclient/llmClient.js';
import { spawn, ChildProcess } from 'child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
export const EVAL_DATA_FOLDER = join(__dirname, '../../dataset');

/**
 * This class calls the judge model to evaluate the quality of
 * the LWC component generated by the modelToEval against
 * the reference LWC in the training data
 */
import { MobileWebMcpClient } from '../mcpclient/mobileWebMcpClient.js';

export class Evaluator {
  private readonly evaluatorAgent: LwcEvaluatorAgent;
  private readonly componentAgent: LwcComponentAgent;
  private serverProcess: ChildProcess;
  private mobileWebMcpClient: MobileWebMcpClient;

  private constructor() {
    // Check judge model environment variables are set
    if (
      !process.env.JUDGE_MODEL ||
      !process.env.JUDGE_MODEL_PROVIDER ||
      !process.env.JUDGE_MODEL_API_KEY ||
      !process.env.JUDGE_MODEL_BASE_URL ||
      !process.env.JUDGE_MODEL_CLIENT_FEATURE_ID ||
      !process.env.JUDGE_MODEL_TENANT_ID
    ) {
      throw new Error(
        'JUDGE_MODEL, JUDGE_PROVIDER, JUDGE_MODEL_API_KEY, JUDGE_MODEL_BASE_URL, JUDGE_MODEL_CLIENT_FEATURE_ID, and JUDGE_MODEL_TENANT_ID must be set'
      );
    }
    const evaluatorLlmClient = new LlmClient({
      model: process.env.JUDGE_MODEL,
      provider: process.env.JUDGE_MODEL_PROVIDER,
      apiKey: process.env.JUDGE_MODEL_API_KEY,
      baseUrl: process.env.JUDGE_MODEL_BASE_URL,
      clientFeatureID: process.env.JUDGE_MODEL_CLIENT_FEATURE_ID,
      tenantId: process.env.JUDGE_MODEL_TENANT_ID,
    });
    this.evaluatorAgent = new LwcEvaluatorAgent(evaluatorLlmClient);

    // Check environment variables for model to eval are set
    if (
      !process.env.MODEL_TO_EVAL ||
      !process.env.MODEL_TO_EVAL_PROVIDER ||
      !process.env.MODEL_TO_EVAL_API_KEY ||
      !process.env.MODEL_TO_EVAL_BASE_URL ||
      !process.env.MODEL_TO_EVAL_CLIENT_FEATURE_ID ||
      !process.env.MODEL_TO_EVAL_TENANT_ID
    ) {
      throw new Error(
        'MODEL_TO_EVAL, MODEL_TO_EVAL_PROVIDER, MODEL_TO_EVAL_API_KEY, MODEL_TO_EVAL_BASE_URL, MODEL_TO_EVAL_CLIENT_FEATURE_ID, and MODEL_TO_EVAL_TENANT_ID must be set'
      );
    }
    const componentLlmClient = new LlmClient({
      model: process.env.MODEL_TO_EVAL,
      provider: process.env.MODEL_TO_EVAL_PROVIDER,
      apiKey: process.env.MODEL_TO_EVAL_API_KEY,
      baseUrl: process.env.MODEL_TO_EVAL_BASE_URL,
      clientFeatureID: process.env.MODEL_TO_EVAL_CLIENT_FEATURE_ID,
      tenantId: process.env.MODEL_TO_EVAL_TENANT_ID,
    });
    this.componentAgent = new LwcComponentAgent(componentLlmClient);
  }

  static async create(): Promise<Evaluator> {
    const evaluator = new Evaluator();
    await evaluator.initializeMobileWebMcpClient();
    return evaluator;
  }

  async destroy(): Promise<void> {
    console.log('🔄 Starting evaluator cleanup...');

    if (this.mobileWebMcpClient) {
      console.log('🔄 Disconnecting MCP client...');
      await this.mobileWebMcpClient.disconnect();
      console.log('✅ MCP client disconnected');
    }

    if (this.serverProcess) {
      console.log('🔄 Terminating server process...');
      this.serverProcess.kill('SIGTERM');
      // Give the process a moment to terminate gracefully
      await new Promise(resolve => setTimeout(resolve, 1000));
      // Force kill if still running
      if (!this.serverProcess.killed) {
        console.log('🔄 Force killing server process...');
        this.serverProcess.kill('SIGKILL');
      }
      console.log('✅ Server process terminated');
    }

    console.log('✅ Evaluator cleanup completed');
  }

  /**
   * Evaluate the quality of the LWC component generated by the modelToEval against the reference LWC implementation
   * @param componentName - The name of the component to evaluate
   * @returns The score of the component
   */
  async evaluate(componentName: string): Promise<Score> {
    const componentPath = join(EVAL_DATA_FOLDER, componentName);
    const evaluationUnit = await loadEvaluationUnit(componentPath);
    if (!evaluationUnit) {
      throw new Error(`Evaluation unit not found for component ${componentName}`);
    }

    const mcpGroundings = await this.getMcpGroundings(evaluationUnit);

    const resultLwc = await this.componentAgent.generateLwcComponent(
      evaluationUnit.query,
      mcpGroundings
    );
    return await this.evaluatorAgent.evaluate(evaluationUnit.answer, resultLwc);
  }

  private async getMcpGroundings(evaluationUnit: EvaluationUnit): Promise<string | undefined> {
    const groundings = [];
    for (const tool of evaluationUnit.mcpTools) {
      const result = await this.mobileWebMcpClient.callTool(tool.toolId, tool.params);
      const groundingContext = result.content?.[0]?.text;
      if (groundingContext) {
        groundings.push(groundingContext);
      }
    }
    return groundings.join('\n');
  }

  private async initializeMobileWebMcpClient(): Promise<void> {
    console.log('🔄 Starting MCP server...');
    this.serverProcess = spawn('npm', ['run', 'mobile-web:server:start'], {
      cwd: path.resolve(__dirname, '../../../..'),
      stdio: ['pipe', 'pipe', 'pipe'],
      shell: true,
    });

    // Add process event handlers for debugging
    this.serverProcess.on('error', error => {
      console.error('❌ Server process error:', error);
    });

    this.serverProcess.on('exit', (code, signal) => {
      console.log(`🔄 Server process exited with code: ${code}, signal: ${signal}`);
    });

    this.mobileWebMcpClient = new MobileWebMcpClient();
    await this.connectToMcpServer();
  }

  /**
   * Connect to the MCP server and wait for it to be ready
   * @param maxRetries - The maximum number of retries
   * @param retryIntervalMs - The interval between retries
   */
  private async connectToMcpServer(
    maxRetries: number = 30,
    retryIntervalMs: number = 1000
  ): Promise<void> {
    let retries = 0;

    while (retries < maxRetries) {
      try {
        // Try to create and connect a test client

        await this.mobileWebMcpClient.connect();
        // If we can list tools, server is ready
        await this.mobileWebMcpClient.listTools();
        console.log('MCP server is ready');
        return;
      } catch (error) {
        retries++;
        console.log(`Waiting for MCP server to be ready... (attempt ${retries}/${maxRetries})`);

        if (retries >= maxRetries) {
          throw new Error(
            `MCP server failed to start after ${maxRetries} attempts. Last error: ${error}`
          );
        }

        await new Promise(resolve => setTimeout(resolve, retryIntervalMs));
      }
    }
  }
}
